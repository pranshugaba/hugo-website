<div>
  <div id="{{ .Route }}" class="leaflet-map"></div>
  <div class="route__metadata">
    <div class="route__name">
      <div>
        <p id="{{ .Route }}__name"></p>
        <p id="{{ .Route }}__start-time"></p>
      </div>
      <p id="{{ .Route }}__type"></p>
    </div>
    <div class="route__stats">
      <p id="{{ .Route }}__distance"></p>
      <p id="{{ .Route }}__duration"></p>
      <p id="{{ .Route }}__speed"></p>
    </div>
  </div>
</div>

{{ $images := .Context.Page.Resources.Match (printf "%s/*.{jpg,jpeg,png}" .Route) }}
<script>
    {
      let coords = [19.18, 72.82];
      let zoomLevel = 12;
      var corner1 = L.latLng(18.743, 73.394),
      corner2 = L.latLng(19.470, 72.507),
      bounds = L.latLngBounds(corner1, corner2);
      let mymap = L.map('{{ .Route }}', {
        fullscreenControl: true,
        preferCanvas: true,
        zoomSnap: 0.5,
        zoomDelta: 0.5,
        scrollWheelZoom: false,
      }).setView(coords, zoomLevel);

         const ATTR =
        '&copy; <a href="https://stadiamaps.com/" target="_blank" rel="noopener">Stadia Maps</a>, ' +
        '&copy; <a href="https://openmaptiles.org/" target="_blank" rel="noopener">OpenMapTiles</a> ' +
        '&copy; <a href="http://openstreetmap.org" target="_blank" rel="noopener">OpenStreetMap</a>';
      const TILES_URL =
        'https://tiles.stadiamaps.com/tiles/osm_bright/{z}/{x}/{y}{r}.png';

      let Stadia_OSMBright = L.tileLayer(TILES_URL, {
        minZoom: 3,
        maxZoom: 18,
        attribution: ATTR,
      });
      Stadia_OSMBright.addTo(mymap);

      L.control.scale({ imperial: false }).addTo(mymap);

      let gpx = '{{ .Route }}.gpx'; // URL to your GPX file or the GPX itself
      
      function formatNumber (number, precision = 3) {
        if (typeof number === 'undefined' || number === null) return ''
      
        if (number === 0) return '0'
      
        const roundedValue = round(precision, number)
        const floorValue = Math.floor(roundedValue)
      
        const isInteger = Math.abs(floorValue - roundedValue) < Number.EPSILON
      
        const numberOfFloorDigits = String(floorValue).length
        const numberOfDigits = String(roundedValue).length
      
        if (numberOfFloorDigits > precision) {
          return String(floorValue)
        } else {
          const padding = isInteger ? precision - numberOfFloorDigits : precision - numberOfDigits + 1
      
          if (padding > 0) {
            if (isInteger) {
              return `${String(floorValue)}.${'0'.repeat(padding)}`
            } else {
              return `${String(roundedValue)}${'0'.repeat(padding)}`
            }
          } else {
            return String(roundedValue)
          }
        }
      }
      
      function round(precision, number) {
        return parseFloat(number.toPrecision(precision))
      }
      
      function formatDate(date) {
        const options = {
          year: "numeric",
          month: "long",
          day: "numeric",
          hour: "numeric",
          minute: "numeric",
          timeZone: "Asia/Kolkata"
        };
        return new Intl.DateTimeFormat("en-in", options).format(date);
      }

      new L.GPX(gpx, {
        async: true,
        marker_options: {
          shadowUrl: '/img/shadow.png',
          endIconUrl: '/img/enda.png',
          startIconUrl: '/img/starta.png',
          iconSize: [50, 50],
          iconAnchor: [25, 48],
        },
        polyline_options: {
          color: 'azure',
          opacity: 0.9,
          weight: 3,
          lineCap: 'round',
        },
      })
        .on('loaded', function (e) {
          mymap.fitBounds(e.target.getBounds(), {
            padding: [10, 10],
          });
          
          let name = e.target.get_name();
          document.getElementById(
            '{{ .Route }}__name'
          ).innerText = name;
          
          let ex_type = e.target.get_exercise_type();
          if (ex_type){
            document.getElementById(
              '{{ .Route }}__type'
            ).innerText = ex_type;
          }
          
          let distance = e.target.get_distance() / 1000;
          document.getElementById(
            '{{ .Route }}__distance'
          ).innerText = `Distance: ${formatNumber(distance)} km`;
         

          let duration = e.target.get_duration();
          let duration_string = e.target.get_duration_string(duration);
          if (duration) {
            document.getElementById(
              '{{ .Route }}__duration'
            ).innerText = `Duration: ${duration_string}`;
         
            let moving_speed = e.target.get_moving_speed();
            let speed = moving_speed;
            if (speed >= Infinity) {
              speed = e.target.get_average_speed();
            }
            document.getElementById(
              '{{ .Route }}__speed'
            ).innerText = `Avg. Speed: ${formatNumber(speed)} km/h`;
          }
          
          let start_time = new Date(e.target.get_time());
          let formatted_time = formatDate(start_time);
          if (formatted_time) {
            document.getElementById(
              '{{ .Route }}__start-time'
            ).innerText = formatted_time;
          }
        })
        .addTo(mymap);
    }
</script>

<style>
  #{{ .Route }}__name {
    font-weight: 600;
  }
</style>